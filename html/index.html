<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Using a functional programming style on Perl 5</title><meta name="generator" content="scm/S5" /><meta name="defaultView" content="slideshow" /><meta name="controlVis" content="hidden" /><link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" /><link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" /><link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" /><link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" /><script src="ui/default/slides.js" type="text/javascript"></script><style type="text/css">
<!--
/* default style sheet generated by perltidy */
body {background: #FFFFFF; color: #000000}
pre { color: #000000; 
      background: #FFFFFF;
      font-family: courier;
    } 

.c  { color: #228B22;} /* comment */
.cm { color: #000000;} /* comma */
.co { color: #000000;} /* colon */
.h  { color: #CD5555; font-weight:bold;} /* here-doc-target */
.hh { color: #CD5555; font-style:italic;} /* here-doc-text */
.i  { color: #00688B;} /* identifier */
.j  { color: #CD5555; } /* label */
.k  { color: #8B008B; } /* keyword */
.m  { color: #0000FF; } /* subroutine */
.n  { color: #B452CD;} /* numeric */
.p  { color: #000000;} /* paren */
.pd { color: #228B22; font-style:italic;} /* pod-text */
.pu { color: #000000;} /* punctuation */
.q  { color: #CD5555;} /* quote */
.s  { color: #000000;} /* structure */
.sc { color: #000000;} /* semicolon */
.v  { color: #B452CD;} /* v-string */
.w  { color: #000000;} /* bareword */
-->
</style></head><body><div class="layout"><div id="controls"></div><div id="currentSlide"></div><div id="header"></div><div id="footer"><h1>May 28 2015, London Perl Mongers Technical Meeting</h1><h2>Using a functional programming style on Perl 5</h2></div></div><div class="presentation"><div class="slide"><h1>Using a functional programming style on Perl 5</h1><h2>Christian Jaeger</h2><h4>LeafPair.com</h4></div><div class="slide"><h1>Why functional programming in Perl?</h1>I ...<ul><li>used Perl as primary language 1998-2005</li><li>am using Scheme since 2005 if possible</li><li>am still using Perl a lot</li><li>am offering consulting in Perl</li></ul></div><div class="slide"><h1>Overview</h1><ol><li>Functional Programming?</li><li>Can Perl do it?</li><li>Combinators</li><li>Linked lists, lazy evaluation</li><li>Haskell style lazy sequences</li></ol></div><div class="slide"><h1>Functional programming?</h1><p>A functional program</p><ul><li>uses only pure functions and constants<ul><li>a function is pure when:<ul><li>it doesn't have any other effect than returning a result value</li><li>its result value depends only on its arguments</li></ul></li><li>functions may take functions as arguments, and/or return functions</li></ul></li><li>can only have other effects by way of instructing a
non-functional program to do them</li><li>can use method calls if all method implementations are pure</li></ul></div><div class="slide"><h1>Function programming: why?</h1><ul><li>dependencies and flow of data are directly visible from expressions</li><li>no contortions necessary to test
<pre>
<span class="i">TEST</span> <span class="s">{</span> <span class="w">null</span> <span class="w">-&gt;cons</span><span class="s">(</span><span class="n">1</span><span class="s">)</span><span class="i">-&gt;cons</span><span class="s">(</span><span class="n">2</span><span class="s">)</span><span class="i">-&gt;array</span> <span class="s">}</span>
  <span class="s">[</span><span class="n">2</span><span class="cm">,</span><span class="n">1</span><span class="s">]</span><span class="sc">;</span>
</pre></li><li>the ultimate detangling â†’ reliable composability</li></ul></div><div class="slide"><h1>Perl can do it, Right?</h1><ul><li>higher-order functions
<pre>
<span class="k">my</span> <span class="i">@b</span>= <span class="k">map</span> <span class="s">{</span> <span class="i">$_</span>*<span class="i">$_</span> <span class="s">}</span> <span class="i">@a</span><span class="sc">;</span>

</pre></li><li>closures (functions created by other functions)
<pre>
<a name="new_counter-" id="new_counter-"></a><span class="k">sub </span><span class="m">new_counter</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span>
    <span class="k">sub</span> <span class="s">{</span>
        <span class="i">$n</span>++ 
    <span class="s">}</span>
<span class="s">}</span>
<a name="EOF-" id="EOF-"></a></pre></li><li>iteration using recursion
<pre>
<a name="odd-" id="odd-"></a><span class="k">sub </span><span class="m">odd</span>  <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">0</span> <span class="co">:</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<a name="even-" id="even-"></a><span class="k">sub </span><span class="m">even</span> <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">1</span> <span class="co">:</span> <span class="i">odd</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>

<a name="EOF-" id="EOF-"></a></pre></li></ul></div><div class="slide"><h1>Perl can do it, Right?</h1><ul><li>higher-order functions
<pre>
<span class="k">my</span> <span class="i">@b</span>= <span class="k">map</span> <span class="s">{</span> <span class="i">$_</span>*<span class="i">$_</span> <span class="s">}</span> <span class="i">@a</span><span class="sc">;</span>
<span class="c"># hm, map is not taking a function as argument</span>
</pre></li><li>closures (functions created by other functions)
<pre>
<a name="new_counter-" id="new_counter-"></a><span class="k">sub </span><span class="m">new_counter</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span>
    <span class="k">sub</span> <span class="s">{</span>
        <span class="i">$n</span>++ <span class="c"># Ok, that's not actually pure</span>
    <span class="s">}</span>
<span class="s">}</span>
<a name="EOF-" id="EOF-"></a></pre></li><li>iteration using recursion
<pre>
<a name="odd-" id="odd-"></a><span class="k">sub </span><span class="m">odd</span>  <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">0</span> <span class="co">:</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<a name="even-" id="even-"></a><span class="k">sub </span><span class="m">even</span> <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">1</span> <span class="co">:</span> <span class="i">odd</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="c"># oh, Out of memory!</span>
<a name="EOF-" id="EOF-"></a></pre></li></ul></div><div class="slide"><h1>Perl can do it better</h1><ul><li>higher-order functions
<pre>

<a name="array_map-" id="array_map-"></a><span class="k">sub </span><span class="m">array_map</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span><span class="i">$f</span><span class="cm">,</span> <span class="i">$a</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span>
    <span class="s">[</span> <span class="k">map</span> <span class="s">{</span> <span class="i">&amp;$f</span><span class="s">(</span><span class="i">$_</span><span class="s">)</span> <span class="s">}</span> <span class="i">@$a</span> <span class="s">]</span>
<span class="s">}</span>

<a name="square-" id="square-"></a><span class="k">sub </span><span class="m">square</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span><span class="i">$x</span><span class="s">)</span>= <span class="i">@_</span><span class="sc">;</span>
    <span class="i">$x</span> * <span class="i">$x</span>
<span class="s">}</span>

<span class="k">my</span> <span class="i">$b</span>= <span class="i">array_map</span> <span class="i">*square</span><span class="cm">,</span> <span class="i">$a</span><span class="sc">;</span>

<a name="EOF-" id="EOF-"></a></pre></li></ul></div><div class="slide"><h1>Perl can do it better II</h1><ul><li>higher-order functions
<pre>
<span class="k">use</span> <span class="w">Method::Signatures</span><span class="sc">;</span>

<span class="k">func</span> <span class="w">array_map</span> <span class="s">(</span><span class="i">$f</span><span class="cm">,</span> <span class="i">$a</span><span class="s">)</span> <span class="s">{</span>
    <span class="s">[</span> <span class="k">map</span> <span class="s">{</span> <span class="i">&amp;$f</span><span class="s">(</span><span class="i">$_</span><span class="s">)</span> <span class="s">}</span> <span class="i">@$a</span> <span class="s">]</span>
<span class="s">}</span>

<span class="k">func</span> <span class="w">square</span> <span class="s">(</span><span class="i">$x</span><span class="s">)</span> <span class="s">{</span>
    <span class="i">$x</span> * <span class="i">$x</span>
<span class="s">}</span>

<span class="k">my</span> <span class="i">$b</span>= <span class="w">array_map</span> *<span class="w">square</span><span class="cm">,</span> <span class="i">$a</span><span class="sc">;</span>

</pre></li></ul></div><div class="slide"><h1>Perl can do it better III</h1><ul><li>iteration by recursion
<pre>
<a name="odd-" id="odd-"></a><span class="k">sub </span><span class="m">odd</span>  <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">0</span> <span class="co">:</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<a name="even-" id="even-"></a><span class="k">sub </span><span class="m">even</span> <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">1</span> <span class="co">:</span> <span class="i">odd</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="i">odd</span> <span class="n">137001</span> <span class="c"># Out of memory!</span>
<a name="EOF-" id="EOF-"></a></pre><p>to:</p>
<pre>
<span class="k">use</span> <span class="w">Method::Signatures</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Sub::Call::Tail</span><span class="sc">;</span>

<span class="k">func</span> <span class="w">odd</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">0</span> <span class="co">:</span> <span class="w">tail</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="k">func</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">1</span> <span class="co">:</span> <span class="w">tail</span> <span class="w">odd</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="w">odd</span> <span class="n">137001</span> <span class="c"># -&gt; 1</span>
</pre></li></ul></div><div class="slide"><h1>Perl can do it better III</h1><ul><li>iteration by recursion
<pre>
<a name="odd-" id="odd-"></a><span class="k">sub </span><span class="m">odd</span>  <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">0</span> <span class="co">:</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<a name="even-" id="even-"></a><span class="k">sub </span><span class="m">even</span> <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">1</span> <span class="co">:</span> <span class="i">odd</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="i">odd</span> <span class="n">137001</span> <span class="c"># Out of memory!</span>
<a name="EOF-" id="EOF-"></a></pre><p>to:</p>
<pre>
<span class="k">use</span> <span class="w">Method::Signatures</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Sub::Call::Tail</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">strict</span><span class="sc">;</span> <span class="k">use</span> <span class="w">warnings</span><span class="sc">;</span> <span class="k">use</span> <span class="w">warnings</span> <span class="w">FATAL</span> <span class="cm">=&gt;</span> <span class="q">'uninitialized'</span><span class="sc">;</span>

<span class="k">func</span> <span class="w">odd</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">0</span> <span class="co">:</span> <span class="w">tail</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="k">func</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">1</span> <span class="co">:</span> <span class="w">tail</span> <span class="w">odd</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="w">odd</span> <span class="n">137001</span> <span class="c"># -&gt; 1</span>
</pre></li></ul></div><div class="slide"><h1>Perl can do it better III</h1><ul><li>iteration by recursion
<pre>
<a name="odd-" id="odd-"></a><span class="k">sub </span><span class="m">odd</span>  <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">0</span> <span class="co">:</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<a name="even-" id="even-"></a><span class="k">sub </span><span class="m">even</span> <span class="s">{</span> <span class="k">my</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span>=<span class="i">@_</span><span class="sc">;</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">1</span> <span class="co">:</span> <span class="i">odd</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="i">odd</span> <span class="n">137001</span> <span class="c"># Out of memory!</span>
<a name="EOF-" id="EOF-"></a></pre><p>to:</p>
<pre>
<span class="k">use</span> <span class="w">Method::Signatures</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Sub::Call::Tail</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">strict</span><span class="sc">;</span> <span class="k">use</span> <span class="w">warnings</span><span class="sc">;</span> <span class="k">use</span> <span class="w">warnings</span> <span class="w">FATAL</span> <span class="cm">=&gt;</span> <span class="q">'uninitialized'</span><span class="sc">;</span>
<span class="c"># no stringification;</span>

<span class="k">func</span> <span class="w">odd</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">0</span> <span class="co">:</span> <span class="w">tail</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="k">func</span> <span class="w">even</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span> <span class="i">$n</span> == <span class="n">0</span> ? <span class="n">1</span> <span class="co">:</span> <span class="w">tail</span> <span class="w">odd</span> <span class="s">(</span><span class="i">$n</span> - <span class="n">1</span><span class="s">)</span> <span class="s">}</span>
<span class="w">odd</span> <span class="n">137001</span> <span class="c"># -&gt; 1</span>
</pre></li></ul></div><div class="slide"><h1>Perl can do it already?, cont</h1><ul><li>local (nested) functions
<pre>
<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span>= <span class="k">func</span> <span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span> 
    <span class="s">}</span><span class="sc">;</span>
    <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>
</pre></li></ul></div><div class="slide"><h1>Perl can do it already?, cont</h1><ul><li>local (nested) functions
<pre>
<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span>= <span class="k">func</span> <span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span> <span class="c"># Global symbol "$inner"</span>
    <span class="s">}</span><span class="sc">;</span>
    <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>
</pre></li></ul></div><div class="slide"><h1>Perl can do it already?, cont</h1><ul><li>local (nested) functions
<pre>
<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span>= <span class="k">func</span> <span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span> <span class="c"># Global symbol "$inner"</span>
    <span class="s">}</span><span class="sc">;</span>
    <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>
</pre></li><p>change to:</p>
<pre>
<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span><span class="sc">;</span> <span class="i">$inner</span>= <span class="k">func</span> <span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span>
    <span class="s">}</span><span class="sc">;</span> 
    <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>
</pre></ul></div><div class="slide"><h1>Perl can do it already?, cont</h1><ul><li>local (nested) functions
<pre>
<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span>= <span class="k">func</span> <span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span> <span class="c"># Global symbol "$inner"</span>
    <span class="s">}</span><span class="sc">;</span>
    <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>
</pre></li><p>change to:</p>
<pre>
<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span><span class="sc">;</span> <span class="i">$inner</span>= <span class="k">func</span> <span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span> <span class="c"># leaks memory!</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span>
    <span class="s">}</span><span class="sc">;</span> 
    <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>
</pre></ul></div><div class="slide"><h1>Perl can do it with some help</h1>
<pre>
<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span><span class="sc">;</span> <span class="i">$inner</span>= <span class="k">func</span> <span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span> <span class="c"># leaks memory!</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span>
    <span class="s">}</span><span class="sc">;</span> 
    <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>

<span class="k">for</span> <span class="s">(</span><span class="n">1</span>..<span class="n">1e6</span><span class="s">)</span> <span class="s">{</span> <span class="w">outer</span> <span class="n">10</span> <span class="s">}</span><span class="sc">;</span>
</pre><img src="closure-refcycle.svg" width="39%" /></div><div class="slide"><h1>Perl can do it with some help</h1>
<pre>
<span class="k">use</span> <span class="w">Scalar::Util</span> <span class="q">'weaken'</span><span class="sc">;</span>

<a name="Weakened-" id="Weakened-"></a><span class="k">sub </span><span class="m">Weakened ($)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span><span class="i">$ref</span><span class="s">)</span>= <span class="i">@_</span><span class="sc">;</span>
    <span class="w">weaken</span> <span class="i">$_</span>[<span class="n">0</span>]<span class="sc">;</span>
    <span class="i">$ref</span>
<span class="s">}</span>

<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span><span class="sc">;</span> <span class="i">$inner</span>= <span class="k">func</span> <span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span>
    <span class="s">}</span><span class="sc">;</span> 
    <span class="i">Weakened</span><span class="s">(</span><span class="i">$inner</span><span class="s">)</span>-&gt;<span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>

<span class="k">for</span> <span class="s">(</span><span class="n">1</span>..<span class="n">1e6</span><span class="s">)</span> <span class="s">{</span> <span class="w">outer</span> <span class="n">10</span> <span class="s">}</span><span class="sc">;</span>
<a name="EOF-" id="EOF-"></a></pre></div><div class="slide"><h1>.. or with a trick</h1><p>Fixpoint combinator</p>
<pre>
<span class="c"># in FP::fix</span>
<span class="k">func</span> <span class="w">fix</span> <span class="s">(</span><span class="i">$f</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">sub</span> <span class="s">{</span>
	<span class="w">tail</span> <span class="i">&amp;$f</span> <span class="s">(</span><span class="i">fix</span><span class="s">(</span><span class="i">$f</span><span class="s">)</span><span class="cm">,</span> <span class="i">@_</span><span class="s">)</span>
    <span class="s">}</span>
<span class="s">}</span>

<span class="k">func</span> <span class="w">outer</span> <span class="s">(</span><span class="i">$n</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$inner</span>= <span class="w">fix</span> <span class="k">func</span> <span class="s">(</span><span class="i">$inner</span><span class="cm">,</span> <span class="i">$n</span><span class="cm">,</span> <span class="i">$tot</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$n</span> &gt; <span class="n">0</span> ? <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span>-<span class="n">1</span><span class="cm">,</span> <span class="i">$tot</span>*<span class="i">$n</span><span class="s">)</span> <span class="co">:</span> <span class="i">$tot</span>
    <span class="s">}</span><span class="sc">;</span> 
    <span class="i">&amp;$inner</span><span class="s">(</span><span class="i">$n</span><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>

</pre></div><div class="slide"><h1>Combinators</h1><ul><li>"A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments."  <small>(https://en.wikipedia.org/wiki/Combinator)</small></li><li>example: function composition<table cols="2" border="0" cellpadding="8"><tr><td colspan="2">
<pre>
<span class="k">func</span> <span class="w">compose</span> <span class="s">(</span><span class="i">$f</span><span class="cm">,</span><span class="i">$g</span><span class="s">)</span> <span class="s">{</span> <span class="k">sub</span> <span class="s">{</span> <span class="i">&amp;$f</span> <span class="s">(</span><span class="i">&amp;$g</span> <span class="s">(</span><span class="i">@_</span><span class="s">)</span><span class="s">)</span> <span class="s">}</span> <span class="s">}</span>

<span class="k">func</span> <span class="w">inc</span> <span class="s">(</span><span class="i">$x</span><span class="s">)</span> <span class="s">{</span> <span class="i">$x</span> + <span class="n">1</span> <span class="s">}</span>
<span class="k">func</span> <span class="w">square</span> <span class="s">(</span><span class="i">$x</span><span class="s">)</span> <span class="s">{</span> <span class="i">$x</span> * <span class="i">$x</span> <span class="s">}</span>
</pre></td></tr><tr><td>
<pre>
<span class="i">*squareinc</span>= <span class="w">compose</span> *<span class="w">square</span><span class="cm">,</span> <span class="i">*inc</span><span class="sc">;</span>
</pre></td><td>
<pre>
<span class="c"># equivalent to</span>
<span class="k">func</span> <span class="w">squareinc</span> <span class="s">(</span><span class="i">$x</span><span class="s">)</span> <span class="s">{</span>
    <span class="w">square</span> <span class="s">(</span><span class="w">inc</span> <span class="i">$x</span><span class="s">)</span>
<span class="s">}</span>
</pre></td></tr></table></li></ul></div><div class="slide"><h1>Linked lists and lazy evaluation</h1><p>Functional list generation:</p>
<pre>
<span class="w">repl</span>&gt; <span class="i">$l</span>= <span class="s">[</span> <span class="n">2</span><span class="cm">,</span> <span class="k">undef</span> <span class="s">]</span>
<span class="i">$VAR1</span> = <span class="s">[</span> <span class="n">2</span><span class="cm">,</span> <span class="k">undef</span> <span class="s">]</span><span class="sc">;</span>
<span class="w">repl</span>&gt; <span class="i">$m</span>= <span class="s">[</span> <span class="n">1</span><span class="cm">,</span> <span class="i">$l</span> <span class="s">]</span>
<span class="i">$VAR1</span> = <span class="s">[</span> <span class="n">1</span><span class="cm">,</span> <span class="s">[</span> <span class="n">2</span><span class="cm">,</span> <span class="k">undef</span> <span class="s">]</span> <span class="s">]</span><span class="sc">;</span>
<span class="w">repl</span>&gt; <span class="i">$l</span>
<span class="i">$VAR1</span> = <span class="s">[</span> <span class="n">2</span><span class="cm">,</span> <span class="k">undef</span> <span class="s">]</span><span class="sc">;</span>

<span class="w">repl</span>&gt; <span class="s">(</span><span class="w">cons</span> <span class="n">1</span><span class="cm">,</span> <span class="w">cons</span> <span class="n">2</span><span class="cm">,</span> <span class="w">null</span><span class="s">)</span> <span class="i">-&gt; array</span>
<span class="i">$VAR1</span> = <span class="s">[</span> <span class="n">1</span><span class="cm">,</span> <span class="n">2</span> <span class="s">]</span><span class="sc">;</span>
</pre><p>Haskell:</p><pre>Prelude&gt; 1 : 2 : []
[1,2]</pre></div><div class="slide"><h1>Lazy evaluation</h1><p>evaluating expressions only when necessary</p>
<pre>
<span class="w">repl</span>&gt; <span class="i">$x</span> = <span class="i">lazy</span> <span class="s">{</span> <span class="k">warn</span> <span class="q">"evaluating!"</span><span class="sc">;</span> <span class="n">2</span>*<span class="n">3</span> <span class="s">}</span>
<span class="i">$VAR1</span> = <span class="k">bless</span><span class="s">(</span> .. <span class="cm">,</span> <span class="q">'FP::Lazy::Promise'</span> <span class="s">)</span><span class="sc">;</span>
<span class="w">repl</span>&gt; <span class="w">force</span> <span class="i">$x</span>
<span class="w">evaluating</span>! <span class="w">at</span> <span class="s">(</span><span class="k">eval</span> <span class="n">104</span><span class="s">)</span> <span class="w">line</span> <span class="n">1.</span>
<span class="i">$VAR1</span> = <span class="n">6</span><span class="sc">;</span>
<span class="w">repl</span>&gt; <span class="w">force</span> <span class="i">$x</span>
<span class="i">$VAR1</span> = <span class="n">6</span><span class="sc">;</span>

<span class="w">repl</span>&gt; <span class="i">$x</span> = <span class="i">lazy</span> <span class="s">{</span> <span class="n">1</span> / <span class="n">0</span> <span class="s">}</span>
<span class="i">$VAR1</span> = <span class="k">bless</span><span class="s">(</span> .. <span class="cm">,</span> <span class="q">'FP::Lazy::Promise'</span> <span class="s">)</span><span class="sc">;</span>
<span class="w">repl</span>&gt; <span class="w">force</span> <span class="i">$x</span>
<span class="w">Illegal</span> <span class="w">division</span> <span class="w">by</span> <span class="w">zero</span> <span class="w">at</span> <span class="s">(</span><span class="k">eval</span> <span class="n">112</span><span class="s">)</span> <span class="w">line</span> <span class="n">1.</span>
</pre></div><div class="slide"><h1>Haskell style</h1><br /><pre>*Main&gt; let ones = 1 : ones
*Main&gt; take 5 ones
[1,1,1,1,1]

*Main&gt; let alternating = True:False:alternating
*Main&gt; take 5 alternating
[True,False,True,False,True]
</pre><p>Using functional-perl:</p>
<pre>
<span class="w">repl</span>&gt; <span class="k">func</span> <span class="w">ones</span> <span class="s">(</span><span class="s">)</span> <span class="s">{</span> <span class="k">my</span> <span class="i">$ones</span><span class="sc">;</span> <span class="i">$ones</span>= <span class="i">lazy</span> <span class="s">{</span> <span class="w">cons</span> <span class="n">1</span><span class="cm">,</span> <span class="i">$ones</span> <span class="s">}</span><span class="sc">;</span>
                              <span class="w">Weakened</span> <span class="i">$ones</span> <span class="s">}</span>
<span class="w">repl</span>&gt; <span class="w">ones</span><span class="w">-&gt;take</span><span class="s">(</span><span class="n">5</span><span class="s">)</span><span class="i">-&gt;array</span>
<span class="i">$VAR1</span> = <span class="s">[</span> <span class="n">1</span><span class="cm">,</span><span class="n">1</span><span class="cm">,</span><span class="n">1</span><span class="cm">,</span><span class="n">1</span><span class="cm">,</span><span class="n">1</span> <span class="s">]</span><span class="sc">;</span>

</pre></div><div class="slide"><h1>Haskell style: lazy sequences</h1><p>Infinite stream calculated on demand:</p>
<pre>
<span class="w">Prelude</span>&gt; <span class="w">let</span> <span class="w">fibs</span> = <span class="n">1</span><span class="co">:</span><span class="n">1</span><span class="co">:</span><span class="w">zipWith</span> <span class="s">(</span>+<span class="s">)</span> <span class="w">fibs</span> <span class="s">(</span><span class="w">tail</span> <span class="w">fibs</span><span class="s">)</span>
<span class="w">Prelude</span>&gt; <span class="w">take</span> <span class="n">10</span> <span class="w">fibs</span>
<span class="s">[</span><span class="n">1</span><span class="cm">,</span><span class="n">1</span><span class="cm">,</span><span class="n">2</span><span class="cm">,</span><span class="n">3</span><span class="cm">,</span><span class="n">5</span><span class="cm">,</span><span class="n">8</span><span class="cm">,</span><span class="n">13</span><span class="cm">,</span><span class="n">21</span><span class="cm">,</span><span class="n">34</span><span class="cm">,</span><span class="n">55</span><span class="s">]</span>
</pre><p>Using functional-perl:</p>
<pre>
<span class="k">func</span> <span class="w">fibs</span> <span class="s">(</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$fibs</span><span class="sc">;</span> <span class="i">$fibs</span>=
      <span class="w">cons</span> <span class="n">1</span><span class="cm">,</span> <span class="w">cons</span> <span class="n">1</span><span class="cm">,</span> <span class="i">lazy</span> <span class="s">{</span> <span class="w">stream_zip_with</span> *<span class="w">add</span><span class="cm">,</span> <span class="i">$fibs</span><span class="cm">,</span> <span class="w">rest</span> <span class="i">$fibs</span> <span class="s">}</span><span class="sc">;</span>
    <span class="i">$fibs</span>
<span class="s">}</span>
<span class="w">main</span>&gt; <span class="w">fibs</span><span class="w">-&gt;stream_take</span><span class="s">(</span><span class="n">10</span><span class="s">)</span><span class="i">-&gt;array</span>
<span class="i">$VAR1</span> = <span class="s">[</span> <span class="n">1</span><span class="cm">,</span><span class="n">1</span><span class="cm">,</span><span class="n">2</span><span class="cm">,</span><span class="n">3</span><span class="cm">,</span><span class="n">5</span><span class="cm">,</span><span class="n">8</span><span class="cm">,</span><span class="n">13</span><span class="cm">,</span><span class="n">21</span><span class="cm">,</span><span class="n">34</span><span class="cm">,</span><span class="n">55</span> <span class="s">]</span><span class="sc">;</span>
</pre></div><div class="slide"><h1></h1><p>Thanks for listening!</p><p>Questions?</p><p>Get code from  <a href="http://https://github.com/pflanze/functional-perl">https://github.com/pflanze/functional-perl</a></p><p>and discuss on  <a href="http://functional-perl.org">functional-perl.org</a></p></div></div></body></html>
